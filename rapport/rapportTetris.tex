\documentclass[a4paper, 12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english, francais]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{language=C++,
    basicstyle=\small,
    keywordstyle=\color{blue}\small,
    stringstyle=\color{red}\small,
    commentstyle=\color{green}\small,
    morecomment=[l][\color{magenta}]{\#},
    tabsize=2
}
\title{Le vouitris}
\date{?? mars 2019}
\author{Cynthia MAILLARD \and Alexandre DILLON \and Félix ROYER}

\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage

\section*{Remerciements}

\section*{Introduction}

\section{Adaptation et modélisation}
	\subsection{Tétris originel}
		Tetris est un jeu vidéo de puzzle conçu par Alekseï Pajitnov en 1984. Tetris est principalement composé d'une zone de jeu où des pièces de formes différentes, appelées « tétriminos », descendent du haut de l'écran. 
		Durant la chute des tetrominos, le joueur peut déplacer les pièces latéralement, leur faire effectuer une rotation sur elles-mêmes et accélérer la vitesse de la descente dans certaines versions jusqu'à ce qu'elles se pose sur le bas de la zone de jeu ou sur une autre pièce. 
		Le but pour le joueur est de réaliser le plus de lignes possibles. Une fois une ligne complétée, elle disparaît, et les blocs placés au-dessus chutent d'un rang. 
		Lorsque le joueur accumule les pièce et remplie la zone de jeu jusqu’en haut, ce qui empêche l'arrivée de tétriminos supplémentaires, la partie se termine. Le joueur obtient un score, qui dépend essentiellement du nombre de lignes réalisées lors de la partie. On ne peut donc jamais gagner à Tetris, le but étant d’améliorer son précédent score.

		Après la version originale du jeu sortie sur l'\textit{Elektronika 60}, le tétris a connu un succès mondial dans les années 1990 grâce à sa version Gameboy.

		Le jeu a été adapté sur pratiquement toutes les consoles de toutes les générations, soit dans une version strictement identique soit dans une adaptation plus libre ne conservant que certains point du gameplay original. Au début des années 2010, on comptait plus de 65 plate-formes qui possaidait un portage du jeu.

		Tétris s'est imposé comme l'un des plus grands succès de l'histoire du jeu vidéo et l'une de ces icones les plus mondialement connues.

	\subsection{Notre adaptation}
		Notre adaptation est un version multijoueur du Tétris, ou chaque joueur aurait un jeu qui tournerais sur son ordinateur, sur laquelle il jouerais seul avec son clavier. 

		L'objectif hypotétique étant que pour jouer ensemble, deux joueurs puissent télécharger le client du jeu sur leurs ordinateur puis se connectent à un serveur en ligne qui gérerait le déroulement de la partie. 
		Ainsi, on pourrait imaginer que le joueur rédeveloppe son propre client avec son propre interface graphique, et il pourrait jouer sans problème, à condition de reproduire les échanges entre le client et le serveur prévus dans le protocole.

		Cette proposition pésente le risque qu'un joueur recode sa version du client et soit donc capable de tricher, car n'étant plus contraint aux même règles que son adversaire.

		Cela nous a donné une contrainte à respecter : le serveur fait loi. Les clients ne servent qu'à l'affichage du jeu et à la réception des actions de l'utilisateur, mais ne contrôlent pas le déroulement de la partie.

		Les joueurs joueront une partie de Tétris classique, chacun de leur coté. Cependant, pour ne pas limiter l'affrontement à un concours de score, nous avons choisi d'ajouter un système de malus : lorsqu'un joueur parvient à détruire des lignes, son adversaires se voit pénalisé plus ou moins sévérement en fonction du nombre de lignes détruites.

	\subsection{Modélisation du jeu}

		\subsubsection{Architecture réseau}

			Nous avons déjà défini que nous avions besoin d'une architecture client-serveur dans la partie précédente.

			Un problème que nous avons rencontré est que les clients et le serveur doivent être capable d'attendre l'arrivé d'un message sur leur socket, tout en exécutant une boucle simultanément - la fenêtre graphique pour les clients et la boucle de jeu pour le serveur.


			Pour résoudre ce problèmes nous avons séparé la réception des messages dans un thread à part dans les clients et le serveur.

			Ce thread attends la reception d'un message et le place dans une file. Le thread principal récupère ensuite les messages contenu dans cette file et les exploitent, comme on peut le voir sur la figure \ref{fig:rezo}.

			\begin{figure}[bt]
				\centering
				\includegraphics[scale=0.35]{img/archi_reseau.png}
				\caption{Représentation simplifiée des échanges de messages entre les clients et le serveur}
				\label{fig:rezo}
			\end{figure}

			Ainsi, les clients et le serveur vont pouvoir s'envoyer des messages sans problèmes, étant donné qu'il y a en permanence une socket qui écoute la réception de message. L'interprétation des messages est faites durant la boucle principale des deux applications, ce qui ne bloque pas leur exécution.

		\subsubsection{\'Echanges entre les clients et le serveur}

			Notre protocole d'échange tel que l'avons défini implique que le serveur gère seul la partie, et les clients uniquement l'affichage et les interactions de l'utilisateur, par conséquent, les échanges vont consister en la mise à jour de l'état du jeu de la part du serveur et les actions du joueur de la part du client.

			\subsubsection{Les messages du serveur vers le client}

				\begin{itemize}
					\item Game start : message de début de partie, signale le début de la partie aux clients lorsque les deux joueurs sont prêts à jouer
					\item Game over : message de fin de partie, il indique au joueur s'il a gagné, perdu ou s'il y a une égalité
					\item New tetromino : message contenant le prochaine tétromino qui sera utilisé par le client
					\item Update Grid : message qui contient la grille de jeu du joueur
					\item Update Other Grid : message qui contient la grille de l'adversaire, pour l'afficher
					\item Malus start : signale le début d'une période malus pour le joueur ainsi que le type du malus qui s'applique
					\item Malus end : signale la fin de la période de malus actuelle
				\end{itemize}

			\subsubsection{Les messages du client vers le serveur}

				\begin{itemize}
					\item Tétromino placed : contient le tétromino avec sa position et son orientation tel qu'il viens d'être placé par le joueur
					\item Connection lost : message signalant une déconnexion du joueur
				\end{itemize}


\section{Mise en oeuvre}
	\subsection{Le serveur}

	\subsection{La sérialisation}

			Les échanges des messages vus précédemment nécessite une sérialisation afin qu'ils puissent être envoyés par les sockets, ces dernières ne pouvant envoyés que des tableaux d'octet.

			Pour ce projet, nous avons réalisé nos propres classes de sérialisation. Nous nous sommes inspirés des bibliothèques de sérialisation de GamedevFramework ainsi que de SFML/Packet. 
			Notre sérialisation est organisée en deux classe symétrique : Serializer et Deserializer. Elles contiennent tous les deux un tableau dynamique d'octet qui représente les informations sérialisés ainsi qu'une position d'écriture ou de lecture, respectivement pour le serialiseur et le deserialiseur. 
			
			\subsubsection{Sérialisation des types simples}

			Pour la sérailisation des type simple nous utilisons une méthode templatée privée qui peut sérialiser n'importe quel type simple. Cet sérialisation est ensuite appelé par d'autre méthode auxquelles sont assignés des types spécifiques afin d'éviter la sérialisation de type non-désiré.
			L'endianess de cet méthode de sérialisation définit l'endianess de toute notre sérialisation, celle-ci est en big-endian pusique le format big-endian est le format le plus commun au infrastructure réseau.

\begin{lstlisting}[language=C++, caption=Méthode de sérailisation de type simple\, data est notre tableau dynamique\, d la varaible de type T à sérailiser et writePos la position d'écriture du sérialiseur]
template <typename T>
void Serializer::serializeAnyType(T d){
	size_t size = sizeof(T);
	for (size_t i = 0; i < size; ++i) {
		data.push_back(static_cast<uint8_t>(d >> 8*(size-i-1))); 
	}
	writePos += sizeof(T);
}\end{lstlisting}

\begin{figure}[bt]
	\centering
	\includegraphics[scale=0.35]{img/serialisation.png}
	\caption{Représentation simplifiée de la sérialisation d'un entier de 32bit, est ici représenté la sérialisation du second octet avec la position d'écriture égale à n.}
	\label{fig:rezo}
\end{figure}

			\subsubsection{La sérialisation des messages}

			Nos messages sont répartis en deux structures, une pour les échanges client vers serveur et une pour les échanges serveur vers client. Chacune de ces structures contient une union contenant les structures des messages ainsi que le type du message représenté par une énumération.
			Les structures de messages contiennent ensuite ce que chaque message doit envoyer, des types simples ou des objets. La sérialisation des types simples étant réalisée, celles des objets ce fait par l'appel de la sérailisation de types simple pour chaque attribut de l'objet, sauf si l'attribut est lui-même un objet pour lequel on appelera la méthode de sérialisation adéquate, ceci jusqu'à la sérialisation complète de tout l'objet.
			La sérialisation des messages est donc la suivante : on sérialise tout d'aboord le type de message puis la structure de message présente dans l'union correspondante au type du message.

			\subsubsection{La déserialisation}

			Comme précédemment évoquer, le Deserializer est le symétrique du Serializer, de ce fait la déserialisation va effectuer les opérations inverse de la sérialisation. Pour le cas des messages, le Deserializer va d'abord déserialiser la type du message pour savoir quelle methode appeler pour deserialiser le message.

\begin{lstlisting}[language=C++, caption=Méthode de desérailisation de type simple\, data est notre tableau dynamique\, d la varaible de type T à desérailiser et readPos la position de lecture du desérialiseur]
template <typename T>
void Deserializer::deserializeAnyType(T & d){
	T res = 0;
	for (size_t i = 0; i < sizeof(T); ++i) {
		res = (res << 8) + data[readPos+i];
	}
	readPos += sizeof(T);
	d = res;
}\end{lstlisting}

			\subsubsection{Une seule asymétrie entre Serializer et Deserializer}

			Une seule asymétrie entre Serializer et Deserializer existe, il s'agit de la gestion de la taille du message. Car pour envoyé notre message sur une socket, nous devons connaitre sa taille et la spécifier. Pour cela le serialiseur garde toujours huit octets en debut de son tableau dynamique pour que lorsqu'on récupère le tableau d'octet, la taille du tableau soit insérée au debut de celui-ci. Ainsi cela permet lors de la réception du message, de lire les huit premiers octets pour connaitre la taille du message et alloué un tableau dynamique de la bonne taille pour enfin l'assigné à un deserailiseur.

	
	\subsection{Le client graphique}




\section*{Conclusion}


\end{document}